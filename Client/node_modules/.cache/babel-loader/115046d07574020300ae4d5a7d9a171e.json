{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ariaHandler = void 0;\n\nasync function queryAXTree(client, element, accessibleName, role) {\n  const {\n    nodes\n  } = await client.send('Accessibility.queryAXTree', {\n    objectId: element._remoteObject.objectId,\n    accessibleName,\n    role\n  });\n  const filteredNodes = nodes.filter(node => node.role.value !== 'text');\n  return filteredNodes;\n}\n\nfunction parseAriaSelector(selector) {\n  const normalize = value => value.replace(/ +/g, ' ').trim();\n\n  const knownAttributes = new Set(['name', 'role']);\n  const queryOptions = {};\n  const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/;\n  const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n    attribute = attribute.trim();\n    if (!knownAttributes.has(attribute)) throw new Error('Unkown aria attribute \"${groups.attribute}\" in selector');\n    queryOptions[attribute] = normalize(value);\n    return '';\n  });\n  if (defaultName && !queryOptions.name) queryOptions.name = normalize(defaultName);\n  return queryOptions;\n}\n\nconst queryOne = async (element, selector) => {\n  const exeCtx = element.executionContext();\n  const {\n    name,\n    role\n  } = parseAriaSelector(selector);\n  const res = await queryAXTree(exeCtx._client, element, name, role);\n\n  if (res.length < 1) {\n    return null;\n  }\n\n  return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n};\n\nconst waitFor = async (domWorld, selector, options) => {\n  const binding = {\n    name: 'ariaQuerySelector',\n    pptrFunction: async selector => {\n      const document = await domWorld._document();\n      const element = await queryOne(document, selector);\n      return element;\n    }\n  };\n  return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n};\n\nconst queryAll = async (element, selector) => {\n  const exeCtx = element.executionContext();\n  const {\n    name,\n    role\n  } = parseAriaSelector(selector);\n  const res = await queryAXTree(exeCtx._client, element, name, role);\n  return Promise.all(res.map(axNode => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n};\n\nconst queryAllArray = async (element, selector) => {\n  const elementHandles = await queryAll(element, selector);\n  const exeCtx = element.executionContext();\n  const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n  return jsHandle;\n};\n/**\n * @internal\n */\n\n\nexports.ariaHandler = {\n  queryOne,\n  waitFor,\n  queryAll,\n  queryAllArray\n};","map":{"version":3,"sources":["C:/Users/PC/source/repos/LaboratoryApplication/client-app/node_modules/puppeteer/lib/cjs/puppeteer/common/AriaQueryHandler.js"],"names":["Object","defineProperty","exports","value","ariaHandler","queryAXTree","client","element","accessibleName","role","nodes","send","objectId","_remoteObject","filteredNodes","filter","node","parseAriaSelector","selector","normalize","replace","trim","knownAttributes","Set","queryOptions","attributeRegexp","defaultName","_","attribute","has","Error","name","queryOne","exeCtx","executionContext","res","_client","length","_adoptBackendNodeId","backendDOMNodeId","waitFor","domWorld","options","binding","pptrFunction","document","_document","waitForSelectorInPage","globalThis","ariaQuerySelector","queryAll","Promise","all","map","axNode","queryAllArray","elementHandles","jsHandle","evaluateHandle","elements"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ariaHandler = void 0;\nasync function queryAXTree(client, element, accessibleName, role) {\n    const { nodes } = await client.send('Accessibility.queryAXTree', {\n        objectId: element._remoteObject.objectId,\n        accessibleName,\n        role,\n    });\n    const filteredNodes = nodes.filter((node) => node.role.value !== 'text');\n    return filteredNodes;\n}\nfunction parseAriaSelector(selector) {\n    const normalize = (value) => value.replace(/ +/g, ' ').trim();\n    const knownAttributes = new Set(['name', 'role']);\n    const queryOptions = {};\n    const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/;\n    const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n        attribute = attribute.trim();\n        if (!knownAttributes.has(attribute))\n            throw new Error('Unkown aria attribute \"${groups.attribute}\" in selector');\n        queryOptions[attribute] = normalize(value);\n        return '';\n    });\n    if (defaultName && !queryOptions.name)\n        queryOptions.name = normalize(defaultName);\n    return queryOptions;\n}\nconst queryOne = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    if (res.length < 1) {\n        return null;\n    }\n    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n};\nconst waitFor = async (domWorld, selector, options) => {\n    const binding = {\n        name: 'ariaQuerySelector',\n        pptrFunction: async (selector) => {\n            const document = await domWorld._document();\n            const element = await queryOne(document, selector);\n            return element;\n        },\n    };\n    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n};\nconst queryAll = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    return Promise.all(res.map((axNode) => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n};\nconst queryAllArray = async (element, selector) => {\n    const elementHandles = await queryAll(element, selector);\n    const exeCtx = element.executionContext();\n    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n    return jsHandle;\n};\n/**\n * @internal\n */\nexports.ariaHandler = {\n    queryOne,\n    waitFor,\n    queryAll,\n    queryAllArray,\n};\n"]},"metadata":{},"sourceType":"script"}